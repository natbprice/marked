---
title: "POPAN Derivation"
author: "Nathaniel Price"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{POPAN Derivation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## POPAN Model
The net births $B_1, \dots, B_{k-1}$ follow a multinomial distribution with super-population size
$N_s$ and entrance probabilities $\beta_1, \dots, \beta_{k-1}$.

$$\{B_1, \dots, B_{k-1}\} \sim  \text{Multinomial}(N_s; \beta_1, \dots, \beta_{k-1})$$
The number of individuals alive just prior to the first sample time is 

$$B_0 = N_s - \sum_{i=1}^{k-1}{B_i}$$

Number of captured unmarked individuals $u_i$ follows a multinomial distribution 

$$\{u_1, \dots, u_k\} \sim  \text{Multinomial}(N_s; \Psi_1 p_1, \dots, \Psi_k p_k)$$

where $\Psi_i$ is the probability that an individual enters the population, is still
alive, and is not seen before time $i$.

$$\Psi_1 = \beta_0, \Psi_{i+1} = \Psi_i (1 - p_i) \phi_i + \beta_i$$

The probability mass function for the multinomial distribtuion is
$$f(x_1, \dots, x_k) = \frac{n!}{x_1! \cdots x_k!} p_1^{x_1}\cdots p_k^{x_k}$$
$$f(x_1, \dots, x_k) = \binom{n}{x_1, \dots, x_k} \prod_{i=1}^{k}{p_i^{x_k}}$$


Therefore, the likelihood for the probability of first capture is
$$\mathcal{L}(u_1, \dots, u_k) = \binom{N_s}{u_1, \dots, u_k} \left(1 - \sum_{i=1}^{k}{\Psi_i p _i}\right)^{N_s-u_\cdot} \prod_{i=1}^{k}{\left(\Psi_i p_i\right)^{u_i}}$$
By conditioning on the total number of unmarked individuals observed $u_\cdot$ the likelihood can be factored as 

$$\mathcal{L}_1 = \mathcal{L}_{1a} \times \mathcal{L}_{1b} = \binom{N_s}{u_\cdot} \left(\sum_{i=1}^{k}{\Psi_i p _i}\right)^{u_\cdot} \left(1 - \sum_{i=1}^{k}{\Psi_i p _i}\right)^{N_s-u_\cdot} \times \binom{u_\cdot}{u_1, \dots, u_k} \prod_{i=1}^{k}{\left(\frac{\Psi_i p_i}{\sum{\Psi_i p_i}}\right)^{u_i}}$$

The log-likelihood for the first component is

$$\ln \mathcal{L}_{1a} = \ln \binom{N_s}{u_\cdot} + u_\cdot \ln \left(\sum_{i=1}^{k}{\Psi_i p_i}\right) + (N_s-u_\cdot)\ln\left(1 - \sum_{i=1}^{k}{\Psi_i p _i}\right)$$

Substituting gamma functions for the multinomial coefficient, the second component is

$$\mathcal{L}_{1b} = \frac{\Gamma\left(\sum{u_i + 1}\right)}{\prod{\Gamma(u_i + 1)}} \prod_{i=1}^{k}{\left(\frac{\Psi_i p_i}{\sum{\Psi_i p_i}}\right)^{u_i}}$$
The log-likelihood for the second component is

$$\ln \mathcal{L}_{1b} =   \ln \Gamma\left(\sum{u_i + 1}\right) - \sum{\ln \Gamma(u_i + 1)} + \sum_{i=1}^{k}{u_i \ln \left(\frac{\Psi_i p_i}{\sum{\Psi_i p_i}}\right)}$$


## Modified POPAN
If all new individuals are detected, then an individual must have either just
entered or was in the population at the start of the study and has remained undetected. 
Therefore,

$$\Psi_1 = \beta_0, \Psi_{i+1} = \beta_i + \beta_0\prod_{j=1}^{i}{(1 - p_j) \phi_j}$$

Next, we calculate the probability that a previously unseen individual is detected
for the first time. We adjust for the fact that all new individuals are detected.
We define a new variable $\theta$

$$\theta_1 \approx \beta_0 p_1, \theta_{i+1} = \beta_i + \beta_0 p_{i+1} \prod_{j=1}^{i}{(1 - p_j) \phi_j}$$
to be substituted for the product $\Psi_i p_i$ in the original likelihood function.

The first component of the log-likelihood function is 

$$\ln \mathcal{L}_{1a} = \ln \binom{N_s}{u_\cdot} + u_\cdot \ln \left(\sum_{i=1}^{k}{\theta_i}\right) + (N_s-u_\cdot)\ln\left(1 - \sum_{i=1}^{k}{\theta _i}\right)$$

which can be evaluated in R as

```{r, eval = FALSE}
lnl1a  = lchoose(Ns, udot) + udot * log(sum(theta)) +
  (Ns - udot) * log(1 - sum(theta))
```

The second component of the log-likelihood function is

$$\ln \mathcal{L}_{1b} =   \ln \Gamma\left(\sum{u_i + 1}\right) - \sum{\ln \Gamma(u_i + 1)} + \sum_{i=1}^{k}{u_i \ln \left(\frac{\theta_i}{\sum{\theta_i}}\right)}$$

which can be evaluated in R as

```{r, eval = FALSE}
lnl1b  = lfactorial(sum(u)) - sum(lfactorial(u)) +
  sum(u * log((theta) / sum(theta)))
```

## Testing likelihood function

```{r setupSimulation}

# Load package for simulating purchase histories (experimental)
library(PurchaseSims)

# Load tidyverse
library(tidyverse)

# Load Marked
library(marked)


# Helper functions --------------------------------------------------------

# Calculate super population size 
superPopSize <- function(N, nocc, phi) {
  (nocc - 1) * (1 - phi) * N + N
}

# Calculate entrance probability
entranceProb <- function(N, Ns, nocc) {
  (Ns - N) / ((nocc - 1) * Ns)
}

```


```{r simulateData}
# Simulation parameters
N.true <- 1e4
phi.true <- 0.85
p.true <- 0.70
nocc <- 8
Ns.true <- superPopSize(N.true, nocc, phi.true) 
pent.true <- entranceProb(N.true, Ns.true, nocc)
pBirth <- 1

# Simulate data
output <- simul_popan(
  phi = rep(phi.true, nocc),
  p = rep(p.true, nocc),
  pent = rep(pent.true, nocc - 1),
  Ns = Ns.true,
  pBirth = rep(pBirth, nocc)
)

# Create histories
CH <- unite(as_tibble(output$CH), "ch", sep = ",") %>%
  mutate(ID = row_number()) %>%
  filter(ch != paste(rep(0, nocc), collapse = ","))

# Summarize histories
captureData <- CH %>% 
  group_by(ch) %>% 
  summarize(freq = n())

```

```{r runModel}
# Process data
proc <- process.data(captureData %>% as.data.frame(), 
                     model = "js", 
                     begin.time = 1)

# Make design data
ddl <- make.design.data(proc)

# Run model using CMAES optimization method
mod <- crm(
  proc,
  ddl,
  hessian = TRUE,
  method = "CMAES",
  detectAllBirths = TRUE
)

```

```{r evaluateModel}
# Calculate model predictions 
modPred <-
  predict(mod,
          ddl = ddl,
          se = TRUE)

# Error in super population size
Ns.pred <- sum(captureData$freq) + modPred$N[1]
(Ns.pred - Ns.true) / Ns.true

# Error in entrance probability
pent.pred <- modPred$pent$estimate[1]
(pent.pred - pent.true) / pent.true

# Error in recruitment
B <- Ns.true * pent.true
B.pred <- Ns.pred * pent.pred
(B.pred - B) / B

```


```{r simulateGroupData}

# Simulation parameters
N.true2 <- 1e4
phi.true2 <- phi.true/2
p.true2 <- p.true/2
Ns.true2 <- superPopSize(N.true2, nocc, phi.true2) 
pent.true2 <- entranceProb(N.true2, Ns.true2, nocc)

# Simulate data
output2 <- simul_popan(
  phi = rep(phi.true2, nocc),
  p = rep(p.true2, nocc),
  pent = rep(pent.true2, nocc - 1),
  Ns = Ns.true2,
  pBirth = rep(pBirth, nocc)
)

# Create histories
CH2 <- unite(as_tibble(output2$CH), "ch", sep = ",") %>%
  mutate(ID = row_number()) %>%
  filter(ch != paste(rep(0, nocc), collapse = ","))

# Summarize histories
captureData <- full_join(CH %>% mutate(groupID = "A"),
                         CH2 %>% mutate(groupID = "B")) %>% 
  mutate(groupID = as.factor(groupID)) %>% 
  group_by(groupID, ch) %>% 
  summarize(freq = n())

```

```{r runGroupModel}

# Process data
proc = process.data(captureData %>% as.data.frame(), 
                    model = "js", 
                    begin.time = 1,
                    groups = "groupID")

# Make design data
ddl = make.design.data(proc)

# Run model with group variable
mod = crm(proc, 
          ddl, 
          model.parameters = list(Phi = list(formula = ~ groupID),
                                  p = list(formula = ~ groupID),
                                  pent = list(formula = ~ groupID),
                                  N = list(formula = ~ groupID)),
          method = "CMAES",
          detectAllBirths = T,
          hessian = TRUE
          # control = list(maxit = 1e3)
          )


```

```{r evaluateGroupModel}
# Calculate model predictions
modPred <-
  predict(mod,
          ddl = ddl,
          se = TRUE)

# Error in super population size
Ns.pred1 <- sum(captureData$freq[captureData$groupID == "A"]) + modPred$N[1,2]
Ns.pred2 <- sum(captureData$freq[captureData$groupID == "B"]) + modPred$N[2,2]

(Ns.pred1 - Ns.true) / Ns.true
(Ns.pred2 - Ns.true2) / Ns.true2

# Error in entrance probability
pent.pred1 <- modPred$pent$estimate[1]
pent.pred2 <- modPred$pent$estimate[9]

(pent.pred1 - pent.true) / pent.true
(pent.pred2 - pent.true2) / pent.true2

# Error in recruitment
B <- Ns.true * pent.true
B2 <- Ns.true2 * pent.true2
B.pred1 <- Ns.pred1 * pent.pred1
B.pred2 <- Ns.pred2 * pent.pred2

(B.pred1 - B) / B
(B.pred2 - B2) / B2
```

